<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>The Asynchronous Events</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../../files/helpindex.css"
type="text/css">
<link rel="stylesheet" href="../../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/2_interface/1_editors/events/async_events.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! -->

<script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script>
<h2>The Asynchronous Events</h2>

<div class="body-scroll">
<p><img class="center" src="images/editor_objects_async.png" alt=
"Object Editor Async Events"> An <b>asynchronous event</b> is one
that is fired off when <i>GameMaker Studio 2</i> receives a "call
back" from some external source, which can be from the web or from
the device running your game. Basically, you tell <i>GameMaker
Studio 2</i> to do something, like load an image, and it'll start
to do this but continue doing whatever it else it has to do
meanwhile its working. Then, when the request has been completed, a
call-back will be sent to <i>GameMaker Studio 2</i> and any
<b>Asynchronous Events</b> defined for that type of call back will
be fired. Please note that the Asynchronous Events are fired for
<i>all</i> instances that have them, much like the key events, so
you can do an <tt>http_get</tt> call in one instance, yet have the
Asynchronous HTTP event in another to deal with the call
back.<br></p>

<div class="note"><b>NOTE</b>: You should be aware that due to XSS
protection in browsers, requests to and attempts to load resources
from across domains are blocked and may appear to return blank
results when using any of the following events</div>

<p><br>
There are various types of events associated with the Asynchronous
event category, and they are all explained in the sections
below:</p>

<div class="note"><b>NOTE:</b> The variable <tt>async_load</tt>
which is mentioned in the following sections is <b>only valid in
these events</b>, as the <tt>ds_map</tt> that is points to is
created at the start of the event, then deleted again at the end,
with this variable being reset to a value of -1 at all other
times.</div>

<p><br>
</p>

<blockquote><a name="async_audio_play" id="async_audio_play"></a>
<label class="collapse" for="thirteen">Audio Playback</label>
<input id="thirteen" type="checkbox">
<div class="index_list">This event can only be triggered by the
<a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">audio
queue play functions</a> and will return a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">
<tt>ds_map</tt></a> stored in the variable <tt>async_load</tt>,
containing different key/value pairs relating to the audio queue
that has triggered the event. The event is triggered when you have
selected an audio queue to playback and a buffer in that audio
queue is finished playing.<br>
<br>
The following keys will be available in the ds_map:<br>
<br>

<ul>
<li>"<b>queue_id</b>" - the queue index for the queue that has
finished playing, as returned by the function <a href=
"../../../3_scripting/4_gml_reference/audio/audio_create_play_queue.html">
<tt>audio_create_play_queue</tt></a>.</li>

<li>"<b>buffer_id</b>" - the buffer ID for the buffer that is no
longer being played from</li>

<li>"<b>queue_shutdown</b>" - this is set to 0 during normal
playback and 1 when the event is received because <a href=
"../../../3_scripting/4_gml_reference/audio/audio_free_play_queue.html">
<tt>audio_free_play_queue</tt></a> has been called. When this is
set to 1, you don't want to queue up any further data.</li>
</ul>
Since an audio queue can be created from multiple buffers, this
event can be triggered multiple times for one queue as the end of
each section of buffered audio is reached, hence the "buffer_id"
key.<br>
<br>

<div class="note"><b>NOTE:</b> The variable <tt>async_load</tt> is
only valid in the asynchronous events, as the <tt>ds_map</tt> that
is points to is created at the start of the event, then deleted
again at the end, with this variable being reset to a value of -1.
However, all further data-structures created from the event <b>must
be cleaned up using the appropriate functions</b>.</div>
<br>
In the example of use given below we will create an audio queue
with 10 buffered audio sounds added to it and then play the
queue:<br>
<br>

<p class="code">audio_queue = audio_create_play_queue(buffer_s16,
11052, audio_mono);<br>
for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;audio_queue_sound(audio_queue, audio_buffer[i],
0, buffer_get_size(audio_buffer[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
audio_play_sound(audio_queue, 0, true);<br></p>
<br>
Every game step now that the recording is detected will trigger an
asynchronous Audio Recording event where you can deal with the
recorded input something like this:<br>
<br>

<p class="code">var queue = async_load[? "queue_id"];<br>
var num = 0;<br>
if queue = audio_queue<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if async_load[? "buffer_id"] ==
audio_buffer[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_seek(audio_buffer[i],
buffer_seek_start, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;if num == 9<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_stop_sound(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_free_play_queue(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br></p>
<br>
Here we check the queue ID and if it's the one we want, we then
check the buffer ID to see which buffer has finished being played.
We also then set a local var to that index value for checking later
and set the buffer back to the start for that sound. Once our local
variable reaches 9, indicating that the queue has finished, we stop
the sound playing and free the queue.</div>
<br>
<a name="async_audio_rec" id="async_audio_rec"></a> <label class=
"collapse" for="twelve">Audio Recording</label> <input id="twelve"
type="checkbox">
<div class="index_list">This event can only be triggered by the
<a href=
"../../../3_scripting/4_gml_reference/audio/audio_start_recording.html">
<tt>audio_start_recording()</tt></a> function and will return a
<a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">
<tt>ds_map</tt></a> stored in the variable <tt>async_load</tt>,
containing different key/value pairs depending on the call-back
from the function that has triggered the event.<br>
<br>
The following keys will be available in the ds_map:<br>
<br>

<ul>
<li>"<b>buffer_id</b>" - the ID of the temporary buffer you can use
to retrieve the audio data</li>

<li>"<b>channel_index</b>" - the recording channel index as
returned by the calling function that this data came from</li>

<li>"<b>data_len</b>" - the length of data (in bytes) you've
received</li>
</ul>

<div class="note"><b>NOTE:</b> As mentioned at the start of this
page, the variable <tt>async_load</tt> is only valid in the
asynchronous events, as the <tt>ds_map</tt> that is points to is
created at the start of the event, then deleted again at the end.
However, note that the temporary buffer in which all audio is
stored with the map will also be removed at the end of the event so
you should copy it to a custom buffer if you want to keep it for
later use.</div>
<br>
In the usage example below we will create a custom buffer to store
our recorded audio, and also set our game to record from input
source 0:<br>
<br>

<p class="code">channel_index = audio_start_recording(0);<br>
audio_buffer = buffer_create(len, buffer_fast, 1);<br></p>
<br>
Every game step now that the recording is detected will trigger an
asynchronous Audio Recording event where you can deal with the
recorded input something like this:<br>
<br>

<p class="code">var channel = async_load[? "channel_index"];<br>
if channel == channel_index<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;len = async_load[? "data_len"];<br>
&nbsp;&nbsp;&nbsp;buffer_copy(async_load[? "buffer_id"], 0, len,
audio_buffer, 0);<br>
&nbsp;&nbsp;&nbsp;}<br></p>
<br>
Here we simply check the "channel_index" key to make sure it
matches the value returned when we started recording, and if it
does we copy the contents of the temporary buffer created for this
event into our custom buffer. After that you can do what you want
with the custom buffer - you could play it using the dedicated
buffer audio functions, you could process it and send it over the
network, you could save it to disk... Once you have your recorded
audio in a buffer, you can do basically anything you want.</div>
<br>
<a name="async_cloud" id="async_cloud"></a> <label class="collapse"
for="five">Cloud</label> <input id="five" type="checkbox">
<div class="index_list">The Cloud Event is one that is triggered by
the call back from one of the <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">
<tt>cloud_</tt> functions</a>, like <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_synchronise.html">
<tt>cloud_synchronise</tt></a>. It actually generates a
<tt>ds_map</tt> that is exclusive to this event and is stored in
the special variable <b>async_load</b> (please see the individual
functions for code examples that explain the use of this event in
further detail). This ds_map has the following structure:<br>
<br>

<ul>
<li><b>"status":</b> This holds the status code, where a negative
value denotes an error, a description of which will be contained in
the “errorString”. A value of 0 (or a positive value) indicates a
success(see below for exact values), and the “resultString” will
contain the returned data or a success message.</li>

<li style="list-style: none"><br>
</li>

<li><b>"id":</b> The id which was returned from the called
function. If you fire off a series of <tt>cloud_</tt> requests then
you need to know which one you are getting the reply to, and so you
would use this value to compare to the value you stored when you
originally sent the request to find the right one.</li>

<li style="list-style: none"><br>
</li>

<li><b>"description":</b> The description of the last uploaded
file.</li>

<li style="list-style: none"><br>
</li>

<li><b>"resultString":</b> This holds a string which is the data
blob returned from the cloud.</li>

<li style="list-style: none"><br>
</li>

<li><b>"errorString":</b> returns an Error String for any
error.</li>
</ul>
The exact meaning of the returned "status" map entry is explained
in the following table:

<div class="compat">
<table>
<tr>
<th>Status Value</th>
<th>errorString / resultString</th>
<th>Description</th>
</tr>

<tr>
<td>-1</td>
<td>errorString = "Not logged in to &lt;SERVICE&gt;"</td>
<td>You have not successfully logged in to the given Cloud
Service</td>
</tr>

<tr class="alt">
<td>0</td>
<td>resultString = recovered data</td>
<td>New game data downloaded from the cloud (following a
cloud_synchronise call)</td>
</tr>

<tr>
<td>1</td>
<td>resultString = "AlreadySynchronized"</td>
<td>No new data since you last called cloud_synchronise</td>
</tr>

<tr class="alt">
<td>2</td>
<td>resultString = "ConflictDeferral"</td>
<td>A conflict was encountered, but the gamer chose to ignore
it</td>
</tr>

<tr>
<td>3</td>
<td>resultString = "GameUploadSuccess"</td>
<td>data from <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_string_save.html">
<tt>cloud_string_save</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_file_save.html">
<tt>cloud_file_save</tt></a> was successfully uploaded to the
cloud</td>
</tr>

<tr class="alt">
<td>-n</td>
<td>errorString = Description of error</td>
<td>Any other negative number means a synchronisation failure</td>
</tr>
</table>
</div></div>
<br>
<a name="async_dialogue" id="async_dialogue"></a> <label class=
"collapse" for="three">Dialogue</label> <input id="three" type=
"checkbox">
<div class="index_list">Like the above events, the <b>Dialogues</b>
event is only triggered when it gets a call back from one of the
special asynchronous user functions, like <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/get_login_async.html">
<tt>get_login_async()</tt></a> (please see this function for an
extended code example of how this event is used). These events are
the ones that ask for some type of user input, which can be a name,
login details, a number or a colour etc... As most devices do not
like sitting in a loop waiting for a reply, they have to be
asynchronous and <i>GameMaker Studio 2</i> will continue to run in
the background while these functions have a dialogue open and until
they get the required user input which triggers this event.<br>
<br>
Again, a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">
<tt>ds_map</tt></a> is returned with the id held in the special
variable <b>async_load</b>. The values held in this map will depend
on the function used, and you should consult the individual entries
for each function in this manual for more details.</div>
<br>
<a name="async_http" id="async_http"></a> <label class="collapse"
for="two">HTTP</label> <input id="two" type="checkbox">
<div class="index_list">The HTTP Event is one that is triggered by
the call back from one of the <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">
<tt>http_</tt> functions</a>, like <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_post_string.html">
<tt>http_post_string</tt></a>. It actually generates a
<tt>ds_map</tt> (sometimes known as a "dictionary") that is
exclusive to this event and is stored in the special variable
<tt>async_load</tt> (please see the individual functions for code
examples that explain the use of this event in further detail).
This <tt>ds_map</tt> has the following structure:<br>
<br>

<ul>
<li><b>"id":</b> The id which was returned from the command. If you
fire off a series of <tt>http_</tt> requests then you need to know
which one you are getting the reply to, and so you would use this
value to compare to the value you stored when you originally sent
the request to find the right one.</li>

<li style="list-style: none"><br>
</li>

<li><b>"status":</b> Returns a value of less than 0 for an error, 0
for success and 1 if content is being downloaded.</li>

<li style="list-style: none"><br>
</li>

<li><b>"result":</b> The data received (string only), or the path
to the file downloaded if you have used <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_get_file.html">
<tt>http_get_file()</tt></a>.</li>

<li style="list-style: none"><br>
</li>

<li><b>"url":</b> The complete URL you requested.</li>

<li style="list-style: none"><br>
</li>

<li><b>"http_status":</b> The raw http status code (if available).
This returns the standard web status code for most browsers, eg:
304 for "Not Modified" or 204 for "No Content", etc...</li>
</ul>
That is for when you use the <tt>http_post_string()</tt> function,
but each of the <tt>http_</tt> functions may return a slightly
different map, so please refer to the manual entry for each
function to find out the precise data that is returned for it.<br>
<br>

<div class="note"><b>NOTE:</b> As <tt>async_load</tt> creates a
<a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">
<tt>ds_map</tt></a>, these functions are particularly useful when
coupled with the <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_encode.html">
<tt>json_encode</tt></a> and <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html">
<tt>json_decode</tt></a> functions.</div>
<br>
<br>
There could also be additional data supplied by this map if you
have requested files for downloading. In this case, the "status"
will have a value of 1 and the ds_map will hold these extra
keys:<br>
<br>

<ul>
<li><b>"contentLength":</b> This is the size of file that the web
server has said you should expect to receive (may be -1 if the
server does not return this data).</li>

<li style="list-style: none"><br>
</li>

<li><b>"sizeDownloaded":</b> The size of the data that has already
been downloaded.</li>
</ul>
Note that the event will <i>not</i> be triggered for every single
data packet that is received, but will rather update at any time
during the download within the main game loop. Also note that
currently this functionality is only available for regular
<i>Windows</i> target platforms.</div>
<br>
<a name="async_iap" id="async_iap"></a> <label class="collapse"
for="four">IAP</label> <input id="four" type="checkbox">
<div class="index_list">This event can only be triggered by the
various In App Purchase extensions for the different target
platforms available on the Marketplace. This event will always
generate a <b>DS map</b> that is exclusive to this event and stored
in the special variable <tt>async_load</tt>. This DS map will have
different key/value pairs depending on the extension function that
triggered it, but there will always be an "<b>id</b>" key which can
ten be used to identify the type of IAP event that it is. For exact
details of the possible return values and functions that generate
this event, please see the individual PDF manuals included with
each of the extensions.</div>
<br>
<a name="async_image_loaded" id="async_image_loaded"></a>
<label class="collapse" for="one">Image Loaded</label> <input id=
"one" type="checkbox">
<div class="index_list">This event is triggered when you load an
image into <i>GameMaker Studio 2</i>, as long as you have used a
valid URL or path with the applicable load file function. For
example say you want to load a sprite image, and only change the
current sprite for the instance to the new one when it has loaded.
Well you would have something like this in a create event or an
alarm event (for example):

<p class="code">spr =
sprite_add("http://www.angusgames.com/game/background1.png", 0,
false, false, 0, 0);</p>

<p>This will now start to load the image into the device or the
browser, but it will <i>not</i> block <i>GameMaker Studio 2</i>
while it waits for the file to be loaded. Instead <i>GameMaker
Studio 2</i> will keep running as normal until the image is loaded
and the call back triggers the <b>Image Loaded</b> event, where a
<a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">
<tt>ds_map</tt></a> is created and stored in the special variable
<b>async_load</b>. The map contains the following information:</p>

<ul>
<li><b>"filename":</b> The complete path to the file you
requested.</li>

<li style="list-style: none"><br>
</li>

<li><b>"id":</b> The ID of the resource that you have loaded. This
will be the same as the variable that you have assigned the
resource to.</li>

<li style="list-style: none"><br>
</li>

<li><b>"status":</b> Returns a value of less than 0 for an
error.</li>
</ul>

<p>You would then assign the newly loaded image to a background in
this event. The above is also true for sprites and sounds, with a
ds_map being generated for each of these resources as shown above,
and the following code example demonstrates how the returned
information would be used in this event:</p>

<p class="code">if ds_map_find_value(async_load, "id") == spr<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if ds_map_find_value(async_load, "status") &gt;=
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite_index = spr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br></p>

<p>The above code will first check the id of the ds_map that has
been created, then check the status of the callback. If the value
is greater than or equal to 0 (signalling success) the result from
the callback will then be used to set the background index to the
newly loaded image.</p></div>
<br>
<a name="async_networking" id="async_networking"></a> <label class=
"collapse" for="six">Networking</label> <input id="six" type=
"checkbox">
<div class="index_list">The Networking event is one which will be
triggered by any incoming network traffic, and is linked to the
<a href=
"../../../3_scripting/4_gml_reference/networking/index.html">Network
Functions</a>. This event generates a special <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">
ds_map</a> that is exclusive to this event and is stored in the
special variable <b>async_load</b>. This <tt>ds_map</tt> will
contain different information depending on the type of network
event that generated it.

<blockquote><a name="async_network_common" id=
"async_network_common"></a> <label class="collapse" for=
"twenty">Common Networking Events</label> <input id="twenty" type=
"checkbox">
<div class="index_list">The following keys are common to all
received network functions and will always be present in the
<tt>async_load</tt> map:<br>
<br>

<ul>
<li><b>"type":</b> This will have one of the constants listed below
as its return value, and designates the network event type.</li>

<li style="list-style: none"><br>
</li>

<li><b>"id":</b> The socket id (a real number, as returned by the
<a href=
"../../../3_scripting/4_gml_reference/networking/network_create_server.html">
network_create_server</a> or <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_socket.html">
network_create_socket</a> function) that is receiving the event. In
most cases the socket ID returned is the ID of TCP or UDP socket
that triggered the event, however if the event is triggered in a
<i>server</i> and it's a Data Event (see below) then the socket ID
is that of the <i>client</i> that sent the data.</li>

<li style="list-style: none"><br>
</li>

<li><b>"ip":</b> The IP address of the socket (as a string).</li>

<li style="list-style: none"><br>
</li>

<li><b>"port":</b> The port associated with the IP address (useful
when working with UDP).</li>
</ul>
The possible return values for the "type" key can be any of the
three constants listed below:

<div class="compat">
<table>
<tr>
<th>Constant</th>
<th>Description</th>
</tr>

<tr>
<td>network_type_connect</td>
<td>The event was triggered by a connection.</td>
</tr>

<tr class="alt">
<td>network_type_disconnect</td>
<td>The event was triggered by a disconnection.</td>
</tr>

<tr>
<td>network_type_data</td>
<td>The event was triggered by incoming data.</td>
</tr>

<tr class="alt">
<td>network_type_non_blocking_connect</td>
<td>The event was triggered by a connection configured as
non-blocking (you can use the function <a href=
"../../../3_scripting/4_gml_reference/networking/network_set_config.html">
<tt>network_set_config()</tt></a> for this).</td>
</tr>
</table>
</div></div>
<br>
<a name="async_network_connect" id="async_network_connect"></a>
<label class="collapse" for="twentyone">Connecting /
Disconnecting</label> <input id="twentyone" type="checkbox">
<div class="index_list">When you have an event of the type
<tt>network_type_connect</tt> or <tt>network_type_disconnect</tt>,
the <tt>async_load</tt> map will have the following additional
key:<br>
<br>

<ul>
<li><b>"socket":</b> This key will hold the
connecting/disconnecting socket id.</li>

<li style="list-style: none"><br>
</li>
</ul>
If the event is of the type
<tt>network_type_non_blocking_connect</tt>, then additionally there
will be the following key:<br>
<br>

<ul>
<li><b>"succeeded":</b> This key will be either 0 or 1, where 0
means the connection timed out and 1 means it succeeded and the
socket is ready to use.</li>
</ul>
It is worth noting that the Networking Event does not get triggered
in <i>clients</i> when the <i>server</i> disconnects, and that
neither of the <tt>network_type_*</tt> events will be triggered in
clients when the server they are connected to disconnects, even if
the connection is TCP based.</div>
<br>
<a name="async_network_receive" id="async_network_receive"></a>
<label class="collapse" for="twentytwo">Receiving Data</label>
<input id="twentytwo" type="checkbox">
<div class="index_list">When you have a <tt>network_type_data</tt>
type event, which signifies that your network has received data,
the map created will have the following keys:<br>
<br>

<ul>
<li><b>"buffer":</b> This is the unique "buffer id" which is
generated by the event. A "grow" type buffer, byte aligned to 1, is
created to hold the id should be stored in a variable and used for
all further function calls to the buffer <i><b>in this
event</b></i>. Just like the <tt>async_load</tt> map, the buffer
created is automatically removed from memory at the end of this
event. For more information on buffers, please see <a href=
"../../../3_scripting/4_gml_reference/buffers/index.html">Reference
- Buffers</a></li>

<li style="list-style: none"><br>
</li>

<li><b>"size":</b> This is the size (in bytes) of the buffer data
that is being received.</li>
</ul>

<div class="note"><b>NOTE:</b> The buffer created is <b>only valid
in these events</b> and will be freed when the event is
over.</div></div></blockquote></div>
<br>
<a name="async_push" id="async_push"></a> <label class="collapse"
for="ten">Push Notification</label> <input id="ten" type=
"checkbox">
<div class="index_list">The Push Notification Event is one that is
triggered by the call back from <b>push notifications</b> on the
device OS, either from a local source using the function <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/push_local_notification.html">
<tt>push_local_notification</tt></a>, or from a remote source (ie:
your server). It generates a <tt>ds_map</tt> that is exclusive to
this event and is stored in the special variable <b>async_load</b>
(please see the individual functions that trigger asynchronous
events for code examples that explain the use of this event in
further detail). This <tt>ds_map</tt> has the following keys:<br>
<br>

<ul>
<li><b>"type":</b> Value can be "local" for a device local
notification, "remote" for a remote notification, or "register" for
remote notification registration.</li>

<li><b>"status":</b> Value will be "1" for success or "0" for an
error.</li>
</ul>
There may be additional key entries based on the "type" returned
and the "status" value. For "status", if an error has been returned
("0"), then you will also have the following key:<br>
<br>

<ul>
<li><b>"error":</b> Contains details of the error received.</li>
</ul>
If the "status" value is 1 (ie: no errors) then the <tt>ds_map</tt>
will contain the following additional values, depending on the
value of the "type" key:<br>
<br>

<ul>
<li><b>"reg_id":</b> If the "type" received was "register", then
this key will hold the device registration id for remote
notifications.</li>

<li><b>"data":</b> If the "type" received was "local" or "remote",
then this key will hold the string payload that you defined when
you called the notification function.</li>
</ul>
To understand this better, we have created a small example snippet
below for you to look at. In this example we will send a local push
notification using the following code:<br>
<br>

<p class="code">var fireTime =
date_inc_day(date_current_datetime(), 1);<br>
var data = "daily_reward";<br>
push_local_notification(fireTime, "Ahoy!", "Catch The Haggis Has A
Present", data);<br></p>
<br>
This will set a timer to "push" a notification to the device when
one day has passed. When the day is up, if your game is either in
the background or not running, a notification will be shown to the
user with the given title and message (on iOS, the game name is
shown and the title is ignored), and then an asynchronous Push
Notification Event will be called. Note that if the game is in the
foreground when the time for the notification comes, it will
<i>not</i> be shown, but the asynchronous event <b>will still
trigger</b>. In the event itself you would handle the callback
something like this:<br>
<br>

<p class="code">var type = ds_map_find_value(async_load,
"type");<br>
var status = ds_map_find_value(async_load, "status");<br>
if status == 0<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;//error of some kind<br>
&nbsp;&nbsp;&nbsp;var error = ds_map_find_value(async_load,
"error");<br>
&nbsp;&nbsp;&nbsp;show_debug_message("error=" + string(error));<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if type == "register"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.reg_id =
ds_map_find_value(async_load, "reg_id");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var data =
ds_map_find_value(async_load, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if data ==
"daily_reward"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.Gold
+= 1000;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br></p></div>
<br>
<a name="async_saveload" id="async_saveload"></a> <label class=
"collapse" for="eleven">Save / Load</label> <input id="eleven"
type="checkbox">
<div class="index_list">This event will be triggered by certain
functions related to loading and saving buffers to files, as well
as when loading or unloading audio from memory. The event itself
will contain the built in <tt>async_load</tt> DS map which will be
populated by the keys required for the specific function. These are
listed in the sections below.

<blockquote><a name="async_saveload_buffers" id=
"async_saveload_buffers"></a> <label class="collapse" for=
"twentynine">Buffers</label> <input id="twentynine" type=
"checkbox">
<div class="index_list">When you use the functions <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_save_async.html">
<tt>buffer_save_async()</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_load_async.html">
<tt>buffer_load_async()</tt></a> an asynchronous event will be
triggered when the data transfer has been completed. This event
will populate the <tt>async_load</tt> map with the following
key/value pairs<br>
<br>

<ul>
<li><b>"id":</b> the ID of the async function as returned by the
function used.</li>

<li><b>"status":</b> will return <tt>true</tt> if the data was
saved/loaded correctly, and <tt>false</tt> otherwise.</li>
</ul>
This permits you to poll the saving/loading progress and display a
message or change rooms etc... when the process is complete.</div>
<br>
<a name="async_saveload_audio" id="async_saveload_audio"></a>
<label class="collapse" for="thirty">Audio Groups</label>
<input id="thirty" type="checkbox">
<div class="index_list">When working with <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20groups.html">Audio
Groups</a>, you can load them an unload them from memory using the
functions <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_load.html"><tt>
audio_group_load()</tt></a> and <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_unload.html">
<tt>audio_group_unload()</tt></a>. When using the load function, it
will trigger this event when the full set of audio files set for
the group has been loaded into memory and will populate the map
with the following key/value pairs:<br>
<br>

<ul>
<li><b>"type":</b> this tells us the type of event being called and
will be "<tt>audiogroup_load</tt>" for loading audio.</li>

<li><b>"group_id":</b> will return the ID of the audio group that
has been loaded (as defined in the <a href=
"../../3_settings/audio.html">Audio Group Editor</a>).</li>
</ul>
When all audio has been loaded for a group, this event will trigger
and it can then be used to change rooms, or play a music track
etc...</div></blockquote></div>
<br>
<a name="async_social" id="async_social"></a> <label class=
"collapse" for="eight">Social</label> <input id="eight" type=
"checkbox">
<div class="index_list">This event can only be triggered by the
various specific <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">
Social Functions</a> and will return a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">
<tt>ds_map</tt></a> stored in the variable <tt>async_load</tt>,
containing different key/value pairs depending on the callback from
the function that has triggered the event.<br>
<br>
The ds_map will contain a number of keys, the most important of
which is the "<i>id</i>" key. This will return a <b>constant</b>
which can then be checked in code to determine which of the many
callbacks the event has received. Once you have parsed this key and
compared the value returned with the available constants, you can
then continue to extract the rest of the information from the map.

<blockquote><a name="async_social_leaderboards" id=
"async_social_leaderboards"></a> <label class="collapse" for=
"twentyseven">Leaderboards and Achievements</label> <input id=
"twentyseven" type="checkbox">
<div class="index_list">The function pages on <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/achievements%20and%20leaderboards/index.html">
Social Gaming - Achievements and Leaderboards</a> in the Reference
section detail the functions and callbacks as well as the constants
used to trigger this event, but there are also certain
circumstances in which it will be triggered without a function call
from the game that is running:<br>
<br>

<ul>
<li>when your game is launched from the OS dashboard</li>

<li>when you complete a challenge</li>

<li>when another player completes a challenge</li>

<li>when the game is started from the OS dashboard by selecting a
challenge</li>
</ul>

<p>Any of the above callbacks will trigger the <b>Social Event</b>
and an <tt>async_load</tt> map will be generated with the following
details (note that there is a different "id" key value to define
each of the different reasons that the event was called, but all
other contents of the map are the same):<br>
<br></p>

<ul>
<li>"<b>id</b>" - The value of this key will depend on the type of
callback triggering the event. it can be one of these
constants:<br>
<br>

<ul>
<li><b><tt>achievement_challenge_received</tt></b> - A challenge
has been received<br></li>

<li><b><tt>achievement_challenge_completed</tt></b> - A challenge
has been completed.<br></li>

<li><b><tt>achievement_challenge_completed_by_remote</tt></b> - A
challenge has been completed by the other player.<br></li>

<li><b><tt>achievement_challenge_launched</tt></b> - The game was
launched from the OS dashboard with the given challenge.<br></li>
</ul></li>

<li>"<b>playerid</b>" - The player id for the challenge.<br>
<br></li>

<li>"<b>issuerid</b>" - The id of the person that issued the
challenge.<br>
<br></li>

<li>"<b>state</b>" - The state of the challenge, which will have a
value of 0 - 3 (as a string) for <i>invalid</i>, <i>pending</i>,
<i>completed</i> or <i>declined</i>.<br>
<br></li>

<li>"<b>message</b>" - The text message for challenge.<br>
<br></li>

<li>"<b>issueddate</b>" - The issue date for challenge<br>
<br></li>

<li>"<b>completeddate</b>" - The completion date for challenge.<br>
<br></li>

<li>"<b>type</b>" - The type of challenge given. Can be one of two
constants:<br>
<br>

<ul>
<li><b><tt>achievement_type_score_challenge</tt></b> - A challenge
based on the score value.<br></li>

<li><b><tt>achievement_type_achievement_challenge</tt></b> - A
challenge based on an achievement.<br></li>
</ul></li>

<li>"<b>identifier</b>" - The identifying string for the
challenge.<br>
<br></li>

<li>"<b>score</b>" - The score tied in with the challenge.</li>
</ul>
Below you can find a small snippet of code as an example of
use:<br>
<br>

<p class="code">var ident = ds_map_find_value(async_load, "id"
);<br>
if ident == achievement_challenge_completed;<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;player_id = ds_map_find_value(async_load,
"playerid");<br>
&nbsp;&nbsp;&nbsp;issuer_id = ds_map_find_value(async_load,
"issuerid");<br>
&nbsp;&nbsp;&nbsp;state = ds_map_find_value(async_load,
"state");<br>
&nbsp;&nbsp;&nbsp;date_completed = ds_map_find_value(async_load,
"completeddate");<br>
&nbsp;&nbsp;&nbsp;date_issued = ds_map_find_value(async_load,
"issueddate");<br>
&nbsp;&nbsp;&nbsp;ach_type = ds_map_find_value(async_load,
"type");<br>
&nbsp;&nbsp;&nbsp;ach_ident = ds_map_find_value(async_load,
"identifier");<br>
&nbsp;&nbsp;&nbsp;ach_score = ds_map_find_value(async_load,
"score");<br>
&nbsp;&nbsp;&nbsp;}</p></div>
<br></blockquote></div>
<br>
<a name="async_steam" id="async_steam"></a> <label class="collapse"
for="seven">Steam</label> <input id="seven" type="checkbox">
<div class="index_list">This event can only be triggered by the
<a href=
"../../../3_scripting/4_gml_reference/steam%20api/index.html">Steam
API</a> functions and will return a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">
<tt>ds_map</tt></a> stored in the variable <tt>async_load</tt>,
containing different key/value pairs depending on the call-back
from the function that has triggered the event. The map will always
contain the key "<b>event_type</b>" which can then be parsed to
find the type of function that triggered the event and change the
code required to suit.<br>
<br>
When calling any function that triggers this event, it will
generate a unique async ID value which should be stored in a
variable and checked, as the <tt>async_load</tt> map will always
contain an ID key which you can then parse and ensure that you are
responding to the correct event. In fact, the map will
<i>always</i> hold the following keys, regardless of the Steam
function used to generate the async response:<br>
<br>

<ul>
<li>"<b>id</b>" - The async ID returned by the function that
triggered the event</li>

<li style="list-style: none"><br>
</li>

<li>"<b>result</b>" - The result of the operation (a real value).
This will either be the GML constant <tt>ugc_result_success</tt> or
some other real number. So you should check for this constant to
ensure that the call was successful, and if otherwise something has
not worked correctly. The rest of the possible values returned are
shown as the result of the Steam "EResult" value and you should see
<tt>steamclientpublic.h</tt> in the SDK headers for all 89 possible
values.</li>

<li style="list-style: none"><br>
</li>

<li>"<b>event_type</b>" - A string denoting the type of event (see
below for the details)</li>
</ul>

<blockquote><a name="async_steam_uploading" id=
"async_steam_uploading"></a> <label class="collapse" for=
"twentythree">Uploading Data</label> <input id="twentythree" type=
"checkbox">
<div class="index_list">When using the Steam functions for
uploading a leaderboard (either <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score.html">
<tt>steam_upload_score()</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score_buffer.html">
<tt>steam_upload_score_buffer()</tt></a>) the returned
<tt>ds_map</tt> will have the following key/value pairs:<br>
<br>

<ul>
<li>"<b>event_type</b>" - This key will hold the value
"<b>leaderboard_upload</b>"</li>

<li style="list-style: none"><br>
</li>

<li>"<b>post_id</b>" - This key should match the ID value returned
by the upload calling function</li>

<li style="list-style: none"><br>
</li>

<li>"<b>lb_name</b>" - This key holds the name of the leaderboard
which was posted to</li>

<li style="list-style: none"><br>
</li>

<li>"<b>success</b>" - Will be 1 if the post succeeded, 0
failed</li>

<li style="list-style: none"><br>
</li>

<li>"<b>updated</b>" - Will be 1 if the leaderboard score was
actually updated (ie: the new score was better) or 0 otherwise</li>

<li style="list-style: none"><br>
</li>

<li>"<b>score</b>" - This key holds the score which was posted</li>
</ul>
You can see examples of this on the pages for the score upload
functions.</div>
<br>
<a name="async_steam_downloading" id="async_steam_downloading"></a>
<label class="collapse" for="twentyfour">Downloading
Leaderboards</label> <input id="twentyfour" type="checkbox">
<div class="index_list">When using the Steam functions for
downloading a leaderboard (<a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores.html"><tt>steam_download_scores()</tt></a>,
<a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores_around_user.html">
<tt>steam_download_scores_around_user()</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_friends_scores.html">
<tt>steam_download_friends_scores()</tt></a>) the returned
<tt>ds_map</tt> will have the following key/value pairs:<br>
<br>

<ul>
<li>"<b>event_type</b>" - This key will hold the value
"<b>leaderboard_download</b>"</li>

<li style="list-style: none"><br>
</li>

<li>"<b>id</b>" - This key should match the ID value returned by
the download calling function</li>

<li style="list-style: none"><br>
</li>

<li>"<b>status</b>" - The status of the callback, where -1 equals a
failure or that no results were returned, and 0 equals a
success.</li>

<li>"<b>lb_name</b>" - This key holds the name of the leaderboard
which was posted to</li>

<li style="list-style: none"><br>
</li>

<li>"<b>numEntries</b>" - The number of "rows" of leaderboard data
that is being returned.</li>

<li style="list-style: none"><br>
</li>

<li>"<b>entries</b>" - A JSON object string that contains another
ds_map, which will either contain the key "default" (signifying
that no results are contained within) or the key "entries", which
you can then get the value of. this returned value for "entries"
will be a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20lists/index.html">
<tt>ds_list</tt></a> containing each of the ranks from the
leaderboard, where each entry in the list will itself reference
another <tt>ds_map</tt> which will contain the keys "name", "score"
and "rank", and it may also contain a "data" key depending on the
function used to upload.</li>
</ul>
We will show an example of how downloading score data works by
requesting the top ten ranking for the given leaderboard and
parsing its results in the <b>Steam Async Event</b> (for uploading
examples, please see the appropriate function pages). To start with
we need to request the scores with the following code:<br>
<br>

<p class="code">score_get = steam_download_scores("Game Scores", 1,
10);<br></p>
<br>
This will send off a request to the Steam Server for the scores
from the leaderboard "Game Scores", storing the <b>async ID</b> of
the request in the variable "score_get". This will then be handled
in the <b>Steam Async Event</b> in the following way:<br>
<br>

<p class="code">var async_id = ds_map_find_value(async_load,
"id");<br>
if async_id == score_get<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;var entries = ds_map_find_value(async_load,
"entries");<br>
&nbsp;&nbsp;&nbsp;var map = json_decode(entries);<br>
&nbsp;&nbsp;&nbsp;if ds_map_exists(map, "default")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(map);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var list =
ds_map_find_value(map, "entries");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var len =
ds_list_size(list);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var entry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var i = 0; i &lt; len;
i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry =
ds_list_find_value(list, i );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_name[i]
= ds_map_find_value(entry, "name");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_score[i]
= ds_map_find_value(entry, "score");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_rank[i]
= ds_map_find_value(entry, "rank");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ds_map_exists(entry, "data"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
data = ds_map_find_value(entry, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
buffId = buffer_base64_decode(data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
message = buffer_read(buffId, buffer_string);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message(
" -- attached message: " + string(message));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_delete(buffId);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(entry);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_list_destroy(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;ds_map_destroy(map)<br>
&nbsp;&nbsp;&nbsp;}<br></p>
<br>
What we do here is first check the "id" key of the special
<tt>async_load</tt> map. If this value is the same as the value of
the original call-back function (stored in the "score_get"
variable) we then continue to process the data. The first thing we
do is parse the <tt>async_load</tt> ds_map for the key "entries"
which will contain a JSON object containing the leaderboard data.
This JSON object is then decoded (see <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html">
<tt>json_decode</tt></a>) as another ds_map, and this new map id is
stored in the variable "map".<br>
<br>
This map is checked for the key "default" and if that is found then
the map is destroyed and the event is exited. If no "default" key
is found, the code will then parse the map to extract the necessary
information about the leaderboard, by first extracting a ds_list
from the "entries" key of the ds_map, and then looping through each
entry of the list to get <i>another</i> ds_map with the name, score
and rank of each entry. These values are then stored in arrays and
then we check to see if there is an additional "data" key. If there
is (ie: the score was uploaded with an additional data package)
then we also parse that and send it to the compiler console for
debugging, before destroying the buffer and then continuing on to
destroy the map. Note that if the "data" key is included, it needs
to be decoded using the <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_base64_decode.html">
<tt>buffer_base64_decode()</tt></a> before it can be correctly
read.<br>
<br>
Once the loop has finished, the entries list is destroyed as is the
map that it was taken from. There is no need to destroy the
<tt>async_load</tt> ds_map as this is handled for you by
<i>GameMaker Studio 2</i>.</div>
<br>
<a name="async_steam_downloadingugc" id=
"async_steam_downloadingugc"></a> <label class="collapse" for=
"twentyfive">Downloading UGC (user Generated Content)</label>
<input id="twentyfive" type="checkbox">
<div class="index_list">When using the Steam functions for
downloading <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">
User Generated Content (UGC)</a>, a number of them will trigger
this event. However, each function will generate an
<tt>async_load</tt> ds_map with differing key/value pairs (although
they will always contain the general "<b>id</b>", "<b>result</b>"
and "<b>event_type</b>" keys), so please see the page specific to
the function being used for details and examples.</div>
<br>
<a name="async_steam_ugc_events" id="async_steam_ugc_events"></a>
<label class="collapse" for="twentysix">Unique UGC Events</label>
<input id="twentysix" type="checkbox">
<div class="index_list">The Steam Async event can also be triggered
when a user subscribes to an item outside of the game - for
example, they tab away to a browser and subscribe to a new item
then tab back to the game. In these cases the <tt>async_load</tt>
map will <b>only</b> contain the following details (and none of the
default values listed at the top of this page):<br>
<br>

<ul>
<li>"<b>event_type</b>" - This key will hold the value
"<b>ugc_item_installed</b>"</li>

<li style="list-style: none"><br>
</li>

<li>"<b>published_file_id</b>" - the ID of the newly installed UGC
item (you can use the function <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/steam_ugc_get_item_install_info.html">
<tt>steam_ugc_get_item_install_info()</tt></a> to get the path to
the installed item)</li>

<li style="list-style: none"><br>
</li>
</ul>
The Steam Async event can also be triggered when a workshop item is
subscribed to - either from within the app, or externally from a
workshop browser - and in these cases the <tt>async_load</tt> map
will contain the following key/value pairs:<br>
<br>

<ul>
<li>"<b>event_type</b>" - This key will hold the value
"<b>ugc_item_subscribed"</b>"</li>

<li style="list-style: none"><br>
</li>

<li>"<b>published_file_id</b>" : This key has the published file ID
of the newly subscribed item</li>

<li style="list-style: none"><br>
</li>
</ul>
The event will be triggered should any item be un-subscribed too,
with the DS map holding the following:<br>
<br>

<ul>
<li>"<b>event_type</b>" - This key will hold the value
"<b>ugc_item_unsubscribed"</b>"</li>

<li style="list-style: none"><br>
</li>

<li>"<b>published_file_id</b>" : This key has the published file ID
of the un-subscribed item</li>

<li style="list-style: none"><br>
</li>
</ul></div></blockquote></div>
<br>
<a name="async_system" id="async_system"></a> <label class=
"collapse" for="fourteen">System</label> <input id="fourteen" type=
"checkbox">
<div class="index_list">
<p>This event can only be triggered by a system level event (such
as the detection of a gamepad or the automatic signing in to XBox
Live) and it will return a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">
<tt>ds_map</tt></a> stored in the variable <tt>async_load</tt>,
containing different key/value pairs depending on the system level
event that triggered the call-back.</p>

<blockquote><a name="async_system_gamepads" id=
"async_system_gamepads"></a> <label class="collapse" for=
"thirtyone">Game Pads</label> <input id="thirtyone" type=
"checkbox">
<div class="index_list">
<p>When this event is triggered for a gamepad being connected or
disconnected it will return one of the following key/value pairs in
the <tt>async_load</tt> map:<br>
<br></p>

<ul>
<li>"<b>event_type</b>" - the type of system event received, which
will be one of the following strings:<br>
<br>

<ul>
<li>"<b>gamepad discovered</b>" - happens when the system reports a
new gamepad has been connected</li>

<li>"<b>gamepad lost</b>" - happens when the system has lost
connection to a gamepad</li>
</ul></li>

<li>"<b>pad_index</b>" - the index of the pad that has been added
or removed</li>
</ul>

<p>This event now permits you to move all your gamepad checking
logic from the Step Event or an Alarm event into the System Event
and only run it when it's actually required.</p>

<div class="note"><b>IMPORTANT!</b> This event will NOT be
triggered unless you have at least one <tt>gamepad_*</tt> function
or DnD™ action in your game code. The runner will only initialise
the gamepad sub-system when the functions are used in the project,
so if they aren't present, adding/removing gamepads will not
trigger the System Event.</div>
</div>
<br>
<a name="async_system_gamepads" id="async_system_gamepads"></a>
<label class="collapse" for="thirtythree">Virtual Keyboards</label>
<input id="thirtythree" type="checkbox">
<div class="index_list">
<p>When this event is triggered for a virtual keyboard being opened
or closed it will return the following key/value pairs in the
<tt>async_load</tt> map:<br>
<br></p>

<ul>
<li>"<b>event_type</b>" - the type of system event received, which
will be "<b>virtual keyboard status</b>" for virtual
keyboards.</li>

<li style="list-style: none"><br>
</li>

<li>"<b>screen_height</b>" - the height of the virtual keyboard (in
pixels). This will be 0 if the keyboard is invisible.</li>

<li style="list-style: none"><br>
</li>

<li>"<b>keyboard_status</b>" - the current status of the keyboard,
returned as one of the following strings:<br>
<br>

<ul>
<li>"hiding"</li>

<li>"hidden"</li>

<li>"showing"</li>

<li>"visible"</li>
</ul></li>
</ul>

<p>See <a href=
"../../../3_scripting/4_gml_reference/controls/virtual%20keys/index.html">
here</a> for more information on the virtual keyboard.</p>
</div>
<br>
<a name="async_system_xboxlive" id="async_system_xboxlive"></a>
<label class="collapse" for="thirtytwo">XBox Live</label>
<input id="thirtytwo" type="checkbox">
<div class="index_list">
<p>The asynchronous system event can be triggered when targeting
the <b>XBox One</b> using the <b>UWP</b> export and checking the
<b>Enable XBox Live</b> option in the <a href=
"../../../2_interface/3_settings/game_options/options_windowsuwp.html">
UWP Game Options</a>. When you start <i>GameMaker Studio 2</i> UWP
project that has Xbox Live enabled the project will automatically
try silently sign-in to Xbox Live. The results of this sign-in
attempt will be returned as one of the following key/value pairs in
the <tt>async_load</tt> map:</p>

<ul>
<li>"<b>event_type</b>" - the type of system event received, which
will be one of the following strings:<br>
<br>

<ul>
<li>"<b>user signed in</b>" - the silent user sign-in has been
completed successfully</li>

<li>"<b>user sign in failed</b>" - the silent user sign-in has
failed (when this happens you can use the function <a href=
"../../../3_scripting/4_gml_reference/uwp%20and%20xbox%20live/xboxlive_show_account_picker.html">
<tt>xboxlive_show_account_picker()</tt></a> to get the user to
choose an account to sign in with)</li>

<li>"<b>user signed out</b>" - the user has signed out</li>
</ul></li>
</ul>

<p>For more information on the specific functions available for
XBox Live, please see <a href=
"../../../3_scripting/4_gml_reference/uwp%20and%20xbox%20live/index.html">
here</a>.</p>
</div>
<br>
<a name="async_system_audio" id="async_system_audio"></a>
<label class="collapse" for="thirtyfour">Audio System
Status</label> <input id="thirtyfour" type="checkbox">
<div class="index_list">
<p>This event type is specifically for use when working with the
HTML5 target, as it will be triggered every time the Web Audio
context status changes. This means that if you have, for example, a
piece of looping background music, then you can pause it or stop
and restart it, based on this event triggering. This can be checked
by looking for the following key/value pair in the
<tt>async_load</tt> map:</p>

<ul>
<li>"<b>event_type</b>" - the type of system event received, which
will be the following string for an audio event:<br>
<br>

<ul>
<li>"<b>audio_system_status</b>" - The audio system has initialised
or the context has changed.</li>
</ul></li>
</ul>

<p>If this event type is triggered, then there will be an
additional key in the <tt>async_load</tt> map:</p>

<ul>
<li>"<b>status</b>" - The status of the audio system, which will be
one of the following two strings<br>
<br>

<ul>
<li>"<b>available</b>" - The audio system is initialised and
available to play sounds</li>

<li>"<b>unavailable</b>" - The audio system is not initialised, or
the context is not currently running, and so can't play sounds (all
sound playing functions will return -1)</li>
</ul></li>
</ul>

<p>For more information on the specific functions available for
Audio, please see <a href=
"../../../3_scripting/4_gml_reference/audio/index.html">here</a>.</p>

<div class="note"><b>NOTE</b>: While this event is designed for use
with the HTML5 target, it will also be triggered on <i>all</i>
other platforms, but on everything (except HTML5) it will only be
triggered once on Game Start when the audio engine is first
initialised.</div>
</div></blockquote>
</div></blockquote>

<p><br>
</p>
</div>

<div class="footer">
<div class="buttons">
<div class="clear">
<div style="float:left">Back: <a href="../objects.html">The Object
Editor</a></div>

<div style="float:right">Next: <a href="draw_events.html">Draw
Events</a></div>
</div>
</div>

<h5>© Copyright YoYo Games Ltd. 2019 All Rights Reserved</h5>
</div>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
